Руководство пользователя и справочное руководство версия 5.44.1

CodeMirror - это компонент редактора кода, который может быть встроен в веб-страницы. Библиотека core предоставляет только компонент editor, никаких сопутствующих кнопок, автозаполнение или другие функции IDE. Он предоставляет богатый API, поверх которого такая функциональность может быть реализована прямолинейно. Для повторного использования реализации дополнительных функций см. аддоны, включенные в дистрибутив, и список внешних размещенных аддонов.

CodeMirror работает с языковыми режимами. Режимы - это программы JavaScript, которые помогают раскрашивать (и необязательно отступать) текст, написанный на заданном языке. Дистрибутив поставляется с несколькими режимами (см. mode/ directory), и нетрудно написать новые для других языков.
Основное Использование

Самый простой способ использовать CodeMirror - просто загрузить скрипт и таблицу стилей, найденные в lib/ в дистрибутиве, плюс скрипт режима из одного из каталогов mode/. Например:

<script src="lib/codemirror.js"></script>
<ссылка отн="стилей" с href="Либ/codemirror.стиль CSS>"
<script src="mode/javascript/javascript.js"></script>

(Также можно использовать загрузчик модулей. Подробнее об этом позже.)

После этого можно создать экземпляр редактора следующим образом:

var myCodeMirror = CodeMirror(документ.тело);

Редактор будет добавлен в тело документа, запустится пустым и будет использовать режим, который мы загрузили. Чтобы иметь больше контроля над новым редактором, объект конфигурации может быть передан в CodeMirror в качестве второго аргумента:

var myCodeMirror = CodeMirror(документ.тело, {
  значение: "функция myScript(){возвращает 100;}\n",
  режим: "javascript"
});

Это инициализирует редактор с уже находящимся в нем фрагментом кода и явно говорит ему использовать режим JavaScript (что полезно при загрузке нескольких режимов). Ниже подробное описание опций конфигурации, которые можно CodeMirror.

В тех случаях, когда вы не хотите добавлять редактор к элементу и вам нужно больше контроля над тем, как он вставляется, первым аргументом функции CodeMirror также может быть функция, которая при задании элемента DOM вставляет его куда-то в документ. Это может быть использовано, например, для замены текстового поля реальным редактором:

var myCodeMirror = CodeMirror(функция(elt) {
  myTextArea.parentNode.replaceChild(elt, myTextArea);
}, {value: myTextArea.значение});

Однако для этого варианта использования, который является распространенным способом использования CodeMirror, библиотека предоставляет гораздо более мощный ярлык:

var myCodeMirror = CodeMirror.fromTextArea(myTextArea);

Это, среди прочего, гарантирует, что значение textarea обновляется вместе с содержимым редактора при отправке формы (если она является частью формы). Полное описание этого метода см. В справочнике по API.
Загрузчики модулей

Файлы в дистрибутиве CodeMirror содержат оболочки совместимости для загрузки их (и их зависимостей) в средах AMD или CommonJS. Если переменные exports и module существуют и имеют тип object, будет использоваться CommonJS-style require. Если нет, но есть функция define с присутствующим свойством amd, будет использоваться AMD-style (RequireJS).

Можно использовать Browserify или аналогичные инструменты для статического построения модулей с помощью CodeMirror. Кроме того, используйте RequireJS для динамической загрузки зависимостей во время выполнения. Оба этих подхода имеют то преимущество, что они не используют глобальное пространство имен и могут, таким образом, загружать несколько версий CodeMirror вместе друг с другом.

Вот простой пример использования RequireJS для загрузки CodeMirror:

требовать([
  "см/Либ/codemirror", "см/режим/htmlmixed/htmlmixed"
], функция(CodeMirror) {
  CodeMirror.fromTextArea(документ.метода getElementById("код"), {
    номера линий: true,
    режим: "htmlmixed"
  });
});

Он автоматически загрузит режимы, от которых зависит смешанный режим HTML (XML, JavaScript и CSS). Не используйте опцию RequireJS' paths для настройки пути к CodeMirror, так как это нарушит загрузку подмодулей через относительные пути. Используйте параметр конфигурации пакетов, как показано в:

требовать.конфиг({
  пакеты: [{
    название: "codemirror",
    расположение." :./путь/к/codemirror",
    главная: "lib/codemirror"
  }]
});

Конфигурация

И функция CodeMirror, и ее метод fromTextArea принимают в качестве второго (необязательного) аргумента объект, содержащий параметры конфигурации. Любой вариант не поставляется, как это будет принято с CodeMirror.по умолчанию, объект, содержащий параметры по умолчанию. Этот объект можно обновить, чтобы изменить значения по умолчанию на странице.

Параметры не проверяются никаким образом, поэтому установка фиктивных значений параметров приводит к нечетным ошибкам.

Это поддерживаемые параметры:

значение: string|CodeMirror.Доктор
    Начальное значение редактора. Может быть строкой или объектом документа.
режим: строка|объект
    Режим для использования. Если этот параметр не указан, по умолчанию используется первый загруженный режим. Это может быть строка, либо просто имена режим или тип MIME, связанные с режимом. Кроме того, это может быть объект, содержащий параметры конфигурации для режима, со свойством name, которое называет режим (например, {name: "javascript", json: true}). Демо-страниц для каждого режима содержат информацию о том, какие параметры конфигурации режим поддерживает. Можно спросить CodeMirror, какие режимы и типы MIME были определены путем проверки CodeMirror.режимы и CodeMirror.объекты mimeModes. Первый сопоставляет имена режимов их конструкторам, а второй сопоставляет типы MIME спецификациям режимов.
lineSeparator: строка|null
    Явно задайте разделитель строк для редактора. По умолчанию (значение null), документ будет разделен на CRLFs, а также на lone CRs и LFs, и единственный LF будет использоваться в качестве разделителя строк во всех выходных данных (таких как getValue). Если задана конкретная строка, строки будут разбиты только на эту строку, а в выходных данных по умолчанию будет использоваться тот же разделитель.
тема: строка
    Тема для оформления редактора. Вы должны убедиться, что файл CSS, определяющий соответствующий .загружаются стили cm-s-[name] (см. каталог theme в дистрибутиве). Значение по умолчанию - "default", для которого цвета включены в codemirror.стиль CSS. Можно использовать несколько классов тематизации одновременно—например, "foo bar" назначит редактору классы cm-s-foo и cm-s-bar.
indentUnit: целое число
    Сколько пробелов в блоке (независимо от того, что это означает в редактируемом языке) должно быть отступом. Значение по умолчанию-2.
smartIndent: логические
    Использовать ли контекстно-зависимый отступ, который предоставляет режим (или просто отступ, как и предыдущая строка). По умолчанию true.
tabSize: целое число
    Ширина символа табуляции. По умолчанию 4.
indentWithTabs: boolean
    Следует ли при отступе заменить первые N*табуляций на N табуляций. По умолчанию-false.
electricChars: boolean
    Настраивает, должен ли редактор повторно отступать текущую строку при вводе символа, который может изменить правильный отступ (работает только в том случае, если режим поддерживает отступ). По умолчанию true.
specialChars: Регвыр
    Регулярное выражение, используемое для определения символов, которые должны быть заменены специальным заполнителем. В основном полезно для непечатных специальных символов. Значение по умолчанию /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/.
specialCharPlaceholder: функция(char) → элемент
    Функция, для которой задан специальный символ, определенный параметром specialChars, создает узел DOM, используемый для представления символа. По умолчанию отображается красная точка (•) с подсказкой заголовка, указывающей код символа.
направление: "ltr" | "rtl"
    Переворачивает общую компоновку и выбирает направление базового абзаца слева направо или справа налево. По умолчанию является "л". CodeMirror применяет двунаправленный алгоритм Unicode к каждой строке, но не выполняет автоопределение базового направления — для всех строк задано направление редактора. Результирующий ордер иногда неверен, когда базовое направление не соответствует намерениям пользователя (например, начальная и конечная пунктуация переходит на другую сторону линии). Поэтому для многоязычного ввода полезно разрешить пользователям переключать эту опцию.
rtlMoveVisually: boolean
    Определяет горизонтальное перемещение курсора справа налево (арабский, иврит) текст визуально (нажатие клавиши стрелка влево перемещает курсор влево) или логический (клавишей со стрелкой влево переход к следующему Нижний индекс в строке, которая визуально справа налево). Значение по умолчанию - false в Windows и true на других платформах.
раскладка клавиатуры: строка
    Настраивает карту ключей для использования. Значение по умолчанию - "default", которое является единственной картой ключей, определенной в codemirror.сама js. Дополнительный ключ карты в разделе каталога. См. раздел на ключевых картах для получения дополнительной информации.
extraKeys: объект
    Может использоваться для указания дополнительных Привязок клавиш для редактора, наряду с привязками, определенными в keyMap. Должно быть либо null, либо допустимое значение карты ключей.
configureMouse: ФН(см: CodeMirror, повторите: "один" | "двойник" | "тройной", событие: событие) → объект
    Позволяет настроить поведение выделения и перетаскивания мышью. Функция вызывается при нажатии левой кнопки мыши. Возвращаемый объект может иметь следующие свойства:

    блок: "Чара" | "слово" | "линия" | "прямоугольник" | ФН(CodeMirror, Пос) → {из: поз, чтобы: Пос}
        Единица измерения для выбора. Может быть одним из встроенных блоков или функцией, которая занимает позицию и возвращает диапазон вокруг этого для пользовательского блока. По умолчанию возвращается "word" для двойных кликов, "line" для тройных кликов, "rectangle" для alt-кликов (или, в Chrome OS, meta-shift-кликов) и "single" в противном случае.
    extend: bool
        Следует ли расширить существующий диапазон выбора или начать новый. По умолчанию это включено при щелчке shift.
    addNew: bool
        Если этот параметр включен, новый диапазон добавляется к существующему выделению, а не заменяется. Поведение по умолчанию состоит в том, чтобы включить это для command-click на Mac OS и control-click на других платформах.
    moveOnDrag: bool
